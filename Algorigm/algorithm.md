# Algorithm / DataStructure

List

[1.DP](#dp)  

[2.그리디](#greedy)

[3.DFS/BFS](#dfs-bfs)

[4.HEAP](#heap)

[5.Brute-Force(완전탐색)](#bp)
  
[6.정렬](#sort)  


## DP
`DP 동적프로그래밍`이란 큰 문제를 한번에 해결하기 힘들 때 **작은 문제들을 모아 큰 문제를 해결하는 알고리즘** 기법입니다.  
작은 문제를 풀 때 반복해서 문제를 푸는 기법을 사용하여 값을 저장해 두었다가`(Memoization)` 재사용하는 방법입니다.
이는 상향식 접근법으로 가장 하위의 해답을 구한 후, 해당 결과값을 이용해서 상위 문제를 풀어가는 방식.

`분할정복`이란 
문제를 나눌수 없을 때 까지 나누어서 각각을 풀면서 다시 합병하여 문제의 답을 얻는 알고리즘.
이는 하향식 접근법으로 상위의 해답을 구하기 위해 아래로 내려가면서 하위의 해답을 구하는 방식이다.
문제를 잘게 쪼갤 때, 부분 문제는 서로 중복되지 않는다.

#### § DP 분할정복 
- 공통점 : 문제를 잘게 쪼개서, 가장 작은 단위로 분활
- 차이점 : DP는 부분문제는 중복되어 상위문제 해결시 재활용되지만, 분할정복은 부분 문제는 서로 중복되지 않기 때문에 memoization을 사용하지 않는다.

####Leetcode retry
(#931, #1504)

####programmers retry
(N으로 표현, 정수 삼각형)  

  
## Greedy
탐욕 알고리즘은 간단히 말해서 각 단계에서 최적의 수를 찾는 방법입니다. 탐욕 알고리즘은 정답이라고 볼 수는 없지만 정답과 근접하게 답을 찾는 방법이다. 이런 방법을 통해  
다루기 간단한 뿐만 아니라 빠른 실행 속도가 날 수 있다.
    



## DFS BFS  
DFS(depth firsh search) 는 현재 정점까지 갈 수 있는 점들까지 들어가면서 탐색. 미로에서 갈 수 있을 때 까지 계속 가다가 더 이상 갈 수 없게 되면 다시 가장 가까운 갈림길로 돌아와 이곳부터 다른 방향을 탐색하는 것과 같은 원리이다. 모든 노드들을 방문하고자 할 때 이 방법을 선택하며 스택 or 재귀함수를 이용한다. 
  
    
    
BFS(breath first search)는 현재 가까운 점부터 탐색하는 방법이다. 깊이 탐색하기 전에 넓게 탐색하는 것. 방문한 노드들을 차례로 저장한 후 꺼낼 수 있는 자료구조인 큐를 이용해서 구현한다.

####Leetcode retry
(#1302)


## Heap  
Heap은 완전 이진 트리의 일종으로 `우선순위 큐` 를 위해 만들어진 자료구조이다. 우선순위 큐란 큐와 달리 우선 순위가 높은 데이터가 먼저 나오는 경우이다.  
응급실을 예를 들수 있는데 응급실에는 많은 환자들이 있지만 우선적으로 제일 응급 환자부터 우선 치료된다. 
우선순위 큐는 이와 같은 원리로 구현된다.  우선순위 큐를 구현하는 방법은 `배열, 연결리스트, 힙` 으로 구현된다.  
힙은 `최소힙`과 `최대힙`으로 구성된다. 최소힙이란 부모노드의 값이 항상 하위 노드의 값보다 작은 경우이고 최대 힙은 부모노드의 값이 항상 하위 노드의 값보다 큰 경우이다.  

####programmers retry
(디스크 컨트롤러)  


## BP  
BP(brute-force)는 완전탐색이다. 모든 경우의 수를 다해보는 것을 의미한다.
완전탐색을 위해 대표적으로 4가지 방법을 사용한다.
1. for문  
2. 재귀함수  
3. 순열/조합  
4. 비트마스크  


## SORT
- 버블정렬 : 두 인접한 데이터를 비교해서, 앞에 있는 데이터가 뒤에 있는 데이터 보다 크면 자리를 바꾸는 정렬 알고리즘 이다. 앞에서 부터 2개씩 비교해서 앞에 값이 뒤에 값 보다 크면 바꿔준다.
